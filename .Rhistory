if (!is.null(colors)) {
if (!(length(colors) %in% c(1, length(names)))) {
stop("Length of 'colors' should be 1 or the length of 'names'!")
} else if (length(colors) == 1) {
colors <- rep(colors, length(names))
}
col <- setNames(colors, names)
suppressMessages(p <- p + scale_fill_manual(values = col))
}
return(p)
}
box.plot(x = x, names = names)
library(eppverification)
p <- runif(100, min = 0, max = 0.05)
bh.test(p, alpha = 0.05)
library(Rfast)
x <- matrix( rnorm(50 * 10), ncol = 10 )
res<-coldiffs(x)
rs
res
library(forecast)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
trace("dm.test", edit = T)
374/4
n <- 30
m <- 50
y <- rnorm(n)
x <- matrix(rnorm(n*m), ncol = m)
#Verification Rank Histogram
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE)
library(eppverification)
n <- 30
m <- 50
y <- rnorm(n)
x <- matrix(rnorm(n*m), ncol = m)
#Verification Rank Histogram
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE)
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE, type = "relative")
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE, type = "density")
hist(y,  freq = FALSE)
pit.hist(u = u, bins = 5, var = TRUE, m = TRUE)
n <- 10000
u <- runif(n)
#PIT Histogram
pit.hist(u = u, bins = 5, var = TRUE, m = TRUE)
n <- 10000
u <- runif(n)
#PIT Histogram
pit.hist(u = u, bins = 5, var = TRUE, m = TRUE, type = "relative")
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE, type = "density")
p <- vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE, type = "density")
View(p)
p[["plot_env"]][["f"]]
sum( p[["plot_env"]][["f"]])
n <- 30
m <- 50
y <- rnorm(n)
x <- matrix(rnorm(n*m), ncol = m)
#Verification Rank Histogram
vr.hist(y = y, x = x, bins = 3, ri = TRUE, ent = TRUE)
u <- c(2,3,NA, 3, Inf)
u[is.finite(u)]
any(u > 1) || any(u < 0)
u <- c(0.4, NA)
any(u > 1) || any(u < 0)
mean <- 3
mean
mean(3)
mean(2)
n <- 30
m <- 50
y <- rnorm(n)
x <- matrix(rnorm(n*m), ncol = m)
m <- ncol(x)
i1 <- rep(1:m, times = m)
i2 <- rep(1:m, each = m)
abs(x[, i1]-x[, i2])
i1
abs(x[, i1]-x[, i2])
rowsums(abs(x[, i1]-x[, i2])
rowsums(abs(x[, i1]-x[, i2]))
rowsums(abs(x[, i1]-x[, i2]), parallel = TRUE, na.rm = FALSE)
n <- 30
m <- 50
x <- array(NA, dim = c(2, 2, n))
for (i in 1:n) {
x[, , i] <- cov(cbind(rnorm(m), rgamma(m, shape = 1)))
}
ds(x = x, mean = TRUE)
ds(x = x, mean = FALSE)
n <- 365
m <- 50
x <- array(NA, dim = c(2, 2, n))
for (i in 1:n) {
x[, , i] <- cov(cbind(rnorm(m), rgamma(m, shape = 1)))
}
x
m <- matrix(norm(50*10000), ncol = 50)
m <- matrix(rnorm(50*10000), ncol = 50)
m
cov(m)
Rfast::cova(m)
m
library(tictoc)
tic()
Rfast::cova(m)
toc()
tic()
Rfast::cova(m, large = T)
toc()
tic()
cov(m)
toc()
tic()
Rfast::cova(m)
toc()
tic()
r <- Rfast::cova(m)
toc()
tic()
r2 <- cov(m)
toc()
r
r2
r == r2
r - r2
sum(r - r2)
r
ds(r)
ds(array(r, dim = c(50, 50, 1)))
z <- array(rnorm(50*10000*365), dims = c(10000, 50, 365))
z <- array(rnorm(50*10000*365), dim = c(10000, 50, 365))
z <- array(rnorm(50*10000*30), dims = c(10000, 50, 30))
z <- array(rnorm(50*10000*30), dim = c(10000, 50, 30))
z <- array(rnorm(50*10000*5), dims = c(10000, 50, 5))
z <- array(rnorm(50*10000*5), dim = c(10000, 50, 5))
ds(x = z, covmat = FALSE, mean = FALSE)
ds <- function(x, covmat = FALSE, mean = FALSE, na.rm = FALSE) {
#x is a 3-dimensional array, where each matrix entry stands for a time point.
#Each matrix in that array has to be a covariance matrix.
if (!is.array(x)) {
stop("'x' should be a 3-dimensional array!")
}
symmetry <- apply(x, 3, isSymmetric)
if (!all(symmetry)) {
stop("'x' should contain symmetric matrices!")
}
dimensions <- apply(x, 3, dim)
if(length(unique(dimensions[1, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of rows!")
}
if(length(unique(dimensions[2, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of columns!")
}
ds.value <- c()
d <- ncol(x[, , 1])
if (na.rm) {
index <- which(apply(apply(x, 3, is.finite), 2, all))
} else {
index <- 1:dim(x)[3]
}
if (covmat) {
for (i in index) {
det.x <- det(x[, , i])
det.x[det.x < 0] <- NA
ds.value <- c(ds.value, det.x^(1/(2*d)))
}
} else {
for (i in index) {
r <- cova(x[, , i])
det.x <- det(r)
det.x[det.x < 0] <- NA
ds.value <- c(ds.value, det.x^(1/(2*d)))
}
}
if (mean == TRUE) {
ds.value <- mean(ds.value, na.rm = TRUE)
}
return(ds.value)
}
n <- 30
m <- 50
x <- array(NA, dim = c(2, 2, n))
n <- 30
m <- 50
x <- array(NA, dim = c(2, 2, n))
for (i in 1:n) {
x[, , i] <- cov(cbind(rnorm(m), rgamma(m, shape = 1)))
}
z <- array(rnorm(50*10000*5), dim = c(10000, 50, 5))
ds(x = x, covmat = TRUE, mean = FALSE)
ds(x = x, covmat = TRUE, mean = TRUE)
ds(x = z, covmat = FALSE, mean = FALSE)
ds <- function(x, covmat = FALSE, mean = FALSE, na.rm = FALSE) {
#x is a 3-dimensional array, where each matrix entry stands for a time point.
#Each matrix in that array has to be a covariance matrix.
if (!is.array(x)) {
stop("'x' should be a 3-dimensional array!")
}
dimensions <- apply(x, 3, dim)
if(length(unique(dimensions[1, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of rows!")
}
if(length(unique(dimensions[2, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of columns!")
}
ds.value <- c()
d <- ncol(x[, , 1])
if (na.rm) {
index <- which(apply(apply(x, 3, is.finite), 2, all))
} else {
index <- 1:dim(x)[3]
}
if (covmat) {
symmetry <- apply(x, 3, isSymmetric)
if (!all(symmetry)) {
stop("'x' should contain symmetric matrices!")
}
for (i in index) {
det.x <- det(x[, , i])
det.x[det.x < 0] <- NA
ds.value <- c(ds.value, det.x^(1/(2*d)))
}
} else {
for (i in index) {
r <- cova(x[, , i])
det.x <- det(r)
det.x[det.x < 0] <- NA
ds.value <- c(ds.value, det.x^(1/(2*d)))
}
}
if (mean == TRUE) {
ds.value <- mean(ds.value, na.rm = TRUE)
}
return(ds.value)
}
ds(x = z, covmat = FALSE, mean = FALSE)
ds(x = z, covmat = FALSE, mean = TRUE)
ds(x = z, covmat = FALSE, mean = FALSE)
tic()
ds(x = z, covmat = FALSE, mean = FALSE)
toc()
is.symmetric(cova(z[, , 1]))
z <- array(rnorm(50*10000*5), dim = c(10000, 50, 30))
z <- array(rnorm(50*10000*30), dim = c(10000, 50, 30))
ds(x = z, covmat = FALSE, mean = FALSE)
tic()
ds(x = z, covmat = FALSE, mean = FALSE)
toc()
z <- array(rnorm(50*10000*364), dim = c(10000, 50, 364))
ds(x = z, covmat = FALSE, mean = FALSE)
tic()
ds(x = z, covmat = FALSE, mean = FALSE)
toc()
ds(x = x, covmat = TRUE, mean = FALSE)
ds(x = x, covmat = TRUE, mean = FALSE)
n <- 365
m <- 50
x <- array(NA, dim = c(2, 2, n))
for (i in 1:n) {
x[, , i] <- cov(cbind(rnorm(m), rgamma(m, shape = 1)))
}
ds(x = x, mean = FALSE)
ds(x = x, covmat = T)
tic()
ds(x = x, covmat = T)
toc()
n <- 365
m1 <- 50
m2 <- 10000
y <- cbind(rnorm(n), rgamma(n, shape = 1))
x1 <- array(NA, dim = c(m1, 2, n))
x2 <- array(NA, dim = c(m2, 2, n))
x1[, 1, ] <- rnorm(n*m1)
x1[, 2, ] <- rgamma(n*m1, shape = 1)
x2[, 1, ] <- rnorm(n*m2)
x2[, 2, ] <- rgamma(n*m2, shape = 1)
es(y = y, x = x1, method = "ens", mean = FALSE)
tic()
es(y = y, x = x1, method = "ens", mean = FALSE)
toc()
scoringRules::es_sample(y[1], dat = x1[, , 1])
library(scoringRules)
d <- 10  # number of dimensions
m <- 50  # number of samples from multivariate forecast distribution
mu0 <- rep(0, d)
mu <- rep(1, d)
S0 <- S <- diag(d)
S[S==0] <- 0.1
S0[S0==0] <- 0.2
# generate samples from multivariate normal distributions
obs <- drop(mu0 + rnorm(d) %*% chol(S0))
fc_sample <- replicate(m, drop(mu + rnorm(d) %*% chol(S)))
obs
fc_sample
es_sample(y = obs, dat = fc_sample)
es_sample(y = obs, dat = fc_sample)
for (k in 1:365) {}
for (k in 1:365) {
es_sample(y = obs, dat = fc_sample)
}
n <- 365
m1 <- 50
m2 <- 10000
y <- cbind(rnorm(n), rgamma(n, shape = 1))
x1 <- array(NA, dim = c(m1, 2, n))
x2 <- array(NA, dim = c(m2, 2, n))
x1[, 1, ] <- rnorm(n*m1)
x1[, 2, ] <- rgamma(n*m1, shape = 1)
x2[, 1, ] <- rnorm(n*m2)
x2[, 2, ] <- rgamma(n*m2, shape = 1)
y
es_sample(y = y[1, ], x = t(x1[, , 1]))
es_sample(y = y[1, ], dat = t(x1[, , 1]))
for (k in 1:365) {
es_sample(y = y[1, ], dat = t(x1[, , 1]))
}
x1
tic()
for (k in 1:365) {
es_sample(y = y[k, ], dat = t(x1[, , k]))
}
toc()
tic()
es(y = y, x = x)
toc()
tic()
out <- c()
for (k in 1:365) {
out <- c(out, es_sample(y = y[k, ], dat = t(x1[, , k])))
}
toc()
tic()
es(y = y, x = x)
toc()
out
x1[, , k]
x <- c(3,2, NA)
na.omit(x)
as.vector(na.omit(x))
library(Rfast)
w <- matrix(1, 5, 5)
!is.array(w)
is.matrix(w)
dim()
dim(w)
library(pcaPP)
library(Rfast)
l <- 365
y2 <- matrix(rnorm(d*l), nrow = l)
x2 <- array(rnorm(m*d*l), dim = c(m, d, l))
w_vs <- matrix(1, nrow = d, ncol = d)
y <- rnorm(l)
x <- matrix(rnorm(m*l), ncol = m)
set.seed(123)
d <- 5
m <- 50
l <- 365
y2 <- matrix(rnorm(d*l), nrow = l)
x2 <- array(rnorm(m*d*l), dim = c(m, d, l))
w_vs <- matrix(1, nrow = d, ncol = d)
y <- rnorm(l)
x <- matrix(rnorm(m*l), ncol = m)
x2
dim(x2)
colMeans(x2, dims = 3)
colMeans(x2, dim = 3)
colMeans(x2, dims = 1:2)
sapply(1:dim(x)[3], function(i) colmeans(x[, ,i], parallel = TRUE))
sapply(1:dim(x2)[3], function(i) colmeans(x2[, ,i], parallel = TRUE))
x <- x2
t(sapply(1:dim(x)[3], function(i) colmeans(x[, ,i], parallel = TRUE)))
x2
ee <- function(y, x, method = "median", mean = FALSE, na.rm = FALSE) {
#y is a matrix where the columns represent the obs. variables and the rows stand for the time points
#x is a 3-dimensional array, where each matrix in that array stands for a time point. In each matrix the columns represent the obs. variables
#and the rows represent the number of ensemble members/samples
if (!is.matrix(y)) {
stop("'y' should be a matrix!")
}
if (!is.array(x)) {
stop("'x' should be a 3-dimensional array!")
}
dimensions <- apply(x, 3, dim)
if (nrow(y) != ncol(dimensions)) {
stop("The third dimension of 'x' and the number of rows of 'y' are not equal!")
}
if(length(unique(dimensions[1, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of rows!")
}
if(length(unique(dimensions[2, ])) != 1) {
stop("The entries of 'x' don't have equal numbers of columns!")
}
if(dimensions[2, 1] != ncol(y)) {
stop("The number of columns of the entries of 'x' is not equal with the number of columns of 'y'!")
}
if (method == "median") {
med <- t(sapply(1:dim(x)[3], function(i) l1median_VaZh(x[, , i], maxit = 10000)$par))
ee.values <- sqrt(rowsums((y-med)^2), parallel = TRUE)
} else if (method == "mean") {
mu <- t(sapply(1:dim(x)[3], function(i) colmeans(x[, ,i], parallel = TRUE)))
ee.values <- sqrt(rowsums((y-mu)^2), parallel = TRUE)
} else {
stop("This method is not available!")
}
if (na.rm == TRUE) {
ee.values <- as.vector(na.omit(ee.values))
}
if (mean == TRUE) {
ee.values <- mean(ee.values, na.rm = TRUE)
}
return(ee.values)
}
devtools::load_all()
ee(y2, x2)
y <- y2
x <- x2
med <- t(sapply(1:dim(x)[3], function(i) l1median_VaZh(x[, , i], maxit = 10000)$par))
med
(y-med)^2)
rowsums((y-med)^2)
sqrt(rowsums((y-med)^2, parallel = TRUE))
library(eppverification)
library(eppverification)
library(pcaPP)
library(Rfast)
library(eppverification)
library(Rcpp)
library(ggplot2)
library(eppverification)
#simulated data
n <- 30
m1 <- 50
m2 <- 10000
y <- cbind(rnorm(n), rgamma(n, shape = 1))
x1 <- array(NA, dim = c(m1, 2, n))
x2 <- array(NA, dim = c(m2, 2, n))
x1[, 1, ] <- rnorm(n*m1)
x1[, 2, ] <- rgamma(n*m1, shape = 1)
x2[, 1, ] <- rnorm(n*m2)
x2[, 2, ] <- rgamma(n*m2, shape = 1)
es(y = y, x = x2, method = "mc", mean = FALSE)
z <- array(rnorm(50*10000*5), dim = c(10000, 50, 5))
z <- array(rnorm(50*10000*5), dim = c(10000, 50, 5))
ds(x = z, covmat = FALSE, mean = FALSE)
z <- array(rnorm(10000*5*365), dim = c(10000, 5, 365))
ds(x = z, covmat = FALSE, mean = TRUE)
ds(x = z, covmat = FALSE)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(armadillo)
install.packages("Rcpp")
install.packages("RcppArmadillo")
install.packages("usethis")
usethis::use_rcpp()
usethis::use_rcpp()
usethis::use_rcpp("code")
install.packages("RcppArmadillo")
library(eppverification)
pkgbuild::check_build_tools(debug = TRUE)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(epper)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(eppverification)
library(Rcpp)
registerPlugin("flibs", Rcpp.plugin.maker(libs = "$(FLIBS)"))
sourceCpp(code = '
#ifdef _OPENMP
# include <omp.h>
#endif
#include <Rcpp.h>
// [[Rcpp::plugins(flibs)]]
// [[Rcpp::export]]
void omp_test()
{
#ifdef _OPENMP
Rprintf("OpenMP threads available: %d\\n", omp_get_max_threads());
#else
Rprintf("OpenMP not supported\\n");
#endif
return;
}
')
omp_test()
library(eppverification)
library(eppverification)
rcmdcheck::rcmdcheck()
check
check()
devtools::check()
usethis::use_github_action()
usethis::use_github_action()
library(rcmdcheck)
rcmdcheck()
cran_check_results("eppverification")
library(eppverification)
